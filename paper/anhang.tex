\appendix

\chapter{Grundlagen}

\chapter{Umsetzung}

\section{Implementierung und Optimierung}

\subsection{Implementierung der Vorstufen}

\subsubsection{Filterung}

\begin{code}
\begin{minted}[breaklines,breakafter=\,,fontsize=\small]{cuda}
__global__ void filter_creation_kernel(float* __restrict__ r,
    const std::int32_t* __restrict__ j, std::uint32_t size, float tau)
{
    auto x = blockIdx.x * blockDim.x + threadIdx.x;

    if(x < size)
    {
        if(j[x] == 0)
            r[x] = (1.f / 8.f) * (1.f / powf(tau, 2.f));
        else
        {
            if(j[x] % 2 == 0)
                r[x] = 0.f;
            else
                r[x] = -(1.f / (2.f * powf(j[x], 2.f)
                        * powf(M_PI, 2.f)
                        * powf(tau, 2.f)));
        }
    }
}
\end{minted}
\captionof{listing}{Filtergenerierung}
\label{app:filter_gen}
\end{code}

\begin{code}
\captionof{listing}{Projektionsnormalisierung}
\label{app:filter_norm}
\end{code}

\subsection{Implementierung der gefilterten RÃ¼ckprojektion}

\begin{code}
\begin{minted}[breaklines,breakafter=\,,fontsize=\small]{cuda}
__device__ auto vol_centered_coordinate(unsigned int coord,
                                        std::uint32_t dim,
                                        float size)
    -> float
{
    auto size2 = size / 2.f;
    return -(dim * size2) + size2 + coord * size;
}
\end{minted}
\captionof{listing}{Koordinatensystemtransformation im Volumen}
\label{app:coord_vol}
\end{code}

\begin{code}
\begin{minted}[breaklines,breakafter=\,,fontsize=\small]{cuda}
__device__ auto proj_pixel_coordinate(float coord, std::uint32_t dim,
                                      float size, float offset)
    -> float
{
    auto size2 = size / 2.f;
    auto min = -(dim * size2) - offset;
    return (coord - min) / size - (1.f / 2.f);
}
\end{minted}
\captionof{listing}{Koordinatensystemtransformation auf dem Detektor}
\label{app:coord_det}
\end{code}

\chapter{Analyse}
